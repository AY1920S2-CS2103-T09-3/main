= ExpenseLa - Developer Guide
:site-section: DeveloperGuide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:warning-caption: :warning:
endif::[]
:repoURL: https://github.com/AY1920S2-CS2103-T09-3/main/tree/master

By: `Team Halim`      Since: `Jan 2020`      Licence: `MIT`

== Introduction

ExpenseLa is an application for NUS students to be able to track their spending and also gain insights to their monthly spending through data analytics. The data analytics portion of ExpenseLa aims to aid students in viewing and comparing their monthly expenditure on items of different categories such as shopping and groceries, as well as keeping track of their monthly budgets. ExpenseLa records daily incoming and outgoing transactions and constantly keeps track of the user's budget, income and spending. ExpenseLa is optimised for users who prefer to work with a Command Line Interface (CLI) which works in parallel with a Graphical User Interface (GUI). It is an easy, insight-driven application that hopes to help students keep better track of their expenses.

=== Purpose

This developer guide aims to communicate the design and architecture of the software implementation to developers working on ExpenseLa. It also includes future implementations to give developers an idea of the direction that ExpenseLa intends to take on both current and future features. A developer should be able to understand the design, architecture and future goals of ExpenseLa upon reading this guide.

=== Scope

This developer guide specifies the technical and non-technical details of ExpenseLa. The technical aspects include the design and architecture of the software and the non-technical aspects include the user stories, use cases and non-functional requirements.

== Setting up

Pleas refer to the guide <<SettingUp#, here>>.

== Design

[[Design-Architecture]]
=== Architecture

In this section, we will be introducing the individual components that form ExpenseLa using various diagrams.

.Architecture Diagram
image::ArchitectureDiagram.png[]

The *_Architecture Diagram_* given above explains the high-level design of the App. Given below is a quick overview of each component.

[TIP]
The `.puml` files used to create diagrams in this document can be found in the link:{repoURL}/docs/diagrams/[diagrams] folder.
Refer to the <<UsingPlantUml#, Using PlantUML guide>> to learn how to create and edit diagrams.

`Main` has two classes called link:{repoURL}/src/main/java/seedu/address/Main.java[`Main`] and link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp`]. It is responsible for,

* At app launch: Initializes the components in the correct sequence, and connects them up with each other.
* At shut down: Shuts down the components and invokes cleanup method where necessary.

<<Design-Commons,*`Commons`*>> represents a collection of classes used by multiple other components.
The following class plays an important role at the architecture level:

* `LogsCenter` : Used by many classes to write log messages to the App's log file.

The rest of the App consists of four components.

* <<Design-Ui,*`UI`*>>: The UI of the App.
* <<Design-Logic,*`Logic`*>>: The command executor.
* <<Design-Model,*`Model`*>>: Holds the data of the App in-memory.
* <<Design-Storage,*`Storage`*>>: Reads data from, and writes data to, the hard disk.

Each of the four components

* Defines its _API_ in an `interface` with the same name as the Component.
* Exposes its functionality using a `{Component Name}Manager` class.

For example, the `Logic` component (see the class diagram given below) defines it's API in the `Logic.java` interface and exposes its functionality using the `LogicManager.java` class.

.Class Diagram of the `Logic` Component
image::LogicClassDiagram.png[]

[discrete]
==== How the architecture components interact with each other

The _Sequence Diagram_ below shows how the components interact with each other for the scenario where the user issues the command `delete 1`.

.Component interactions for `delete 1` command
image::ArchitectureSequenceDiagram.png[]

The sections below give more details of each component.

[[Design-Ui]]
=== UI component

.Structure of the UI Component
image::UiClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/address/ui/Ui.java[`Ui.java`]

The UI consists of a `MainWindow` that is made up of parts e.g.`CommandBox`, `ResultDisplay`, `TransactionListPanel`, `StatusBarFooter` etc. All these, including the `MainWindow`, inherit from the abstract `UiPart` class.

The `UI` component uses JavaFx UI framework. The layout of these UI parts are defined in matching `.fxml` files that are in the `src/main/resources/view` folder. For example, the layout of the link:{repoURL}/src/main/java/seedu/address/ui/MainWindow.java[`MainWindow`] is specified in link:{repoURL}/src/main/resources/view/MainWindow.fxml[`MainWindow.fxml`]

The `UI` component does the following actions:

* Executes user commands using the `Logic` component.
* Listens for changes to `Model` data so that the UI can be updated with the modified data.

Hubert

[[Design-Logic]]

=== Logic component

[[fig-LogicClassDiagram]]
.Structure of the Logic Component
image::LogicClassDiagram.png[]

*API* :
link:{repoURL}/src/main/java/seedu/address/logic/Logic.java[`Logic.java`]

Logic is an interface which `LogicManager` implements, allowing access to the API. The following items are examples on how the LogicManager class can be interacted with:

.  `Logic` uses the `ExpenseLaParser` class to parse the user command.
.  This results in a `Command` object which is executed by the `LogicManager`.
.  The command execution can affect the `Model` (e.g. adding a `Transaction`).
.  The result of the command execution is encapsulated as a `CommandResult` object which is passed back to the `Ui`.
.  In addition, the `CommandResult` object can also instruct the `Ui` to perform certain actions, such as displaying help to the user.

Given below is the Sequence Diagram for interactions within the `Logic` component for the `execute("delete 1")` API call.

.Interactions Inside the Logic Component for the `delete 1` Command
image::DeleteSequenceDiagram.png[]

NOTE: The lifeline for `DeleteCommandParser` should end at the destroy marker (X) but due to a limitation of PlantUML, the lifeline reaches the end of diagram.

.Interactions Inside the Logic Component for the `clear` Command
image::ClearSequenceDiagram.png[]

[[Design-Model]]
=== Model component

.Structure of the Model Component
image::ModelClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/address/model/Model.java[`Model.java`]

The `Model`,

* stores a `UserPref` object that represents the user's preferences.
* stores the `ExpenseLa` data.
* stores `TransactionList` which contains the list of all transactions
* exposes an unmodifiable `ObservableList<Transaction>` that can be 'observed' e.g. the UI can be bound to this list so that the UI automatically updates when the data in the list change.
* does not depend on any of the other three components.

[NOTE]
As a more OOP model, we can store a `Tag` list in `Address Book`, which `Person` can reference. This would allow `Address Book` to only require one `Tag` object per unique `Tag`, instead of each `Person` needing their own `Tag` object. An example of how such a model may look like is given below. +
 +
image:BetterModelClassDiagram.png[]

[[Design-Storage]]
=== Storage component

.Structure of the Storage Component
image::StorageClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/address/storage/Storage.java[`Storage.java`]

The `Storage` component,

* can save `UserPref` objects in json format and read it back.
* can save the ExpenseLa data in json format and read it back.

[[Design-Commons]]
=== Common classes

Classes used by multiple components are in the `seedu.ExpenseLa.commons` package.

== Implementation

This section describes some noteworthy details on how certain features are implemented.

// tag::addtransactions[]
=== Adding transactions
We allow users to add Expense/Income transactions into ExpenseLa which denotes a positive or negative inflow of money. This section shows how we handle these requests from the user.

==== Implementation

We store every single `Transaction` added by the user into an `ObservableList<Transaction>`, which is a list object in `TransactionList`. We used an `ObservableList` to easily reflect changes to the list by any other component of ExpenseLa using the list.

There are two ways of implementing a Transaction:
* Adding an expense (negative transaction): add
* Adding an income (positive transaction): add i/
These two commands will indicate whether the transaction is positive or negative.

Indicating whether it is a recurring transaction or not will depend if rc/ is present in the input

When inserting a new Expense/Income, the `AddCommandParser` will determine which object to initialise depending on whether the i/ syntax is present.

The following sequence diagram shows how the add transaction operation works:

image::add-command/AddCommandSequenceDiagram.png[]

Figure 9. Sequence diagram of how adding a new `Transaction` is processed depending on syntax.

`Transaction` are normally instantiated by `AddCommandParser#parse(String args)`, which attempts to parse the various parameters supplied in args and return either a positive or negative `Transaction`. The following conditions will cause a `ParseException` to be thrown by the parser:

* Missing parameters
* Incorrect syntax (i.e. missing prefix if required)
* Illegal values in parameters (i.e. special character and symbols entered for an integer only field)
* Multiple occurence of parameters which only expects single entry

[NOTE]
Incorrect user input will display error message

We will demonstrate how a `Transaction` is added into `ExpenseLa`:

Step 1. The user executes the command add *n/Pizza a/20.5 d/2020-02-02* to insert a negative transaction with its `Name` set to "Pizza", its `Amount` set to "20.50" and the `Date` set to 02 Feb 2020. The input is now checked and an attempt to parse each parameter occurs:

* `**Name**` is parsed by `AddCommandParser#parseName(ArgumentMultimap)`
* `**Value**` is parsed by `AddCommandParser#parseAmount(ArgumentMultimap)`
* `**Date**` is parsed by `AddCommandParser#parseDate(ArgumentMultimap)`
* `**Category**` is set to default category `MISC`

NOTE: `**ArgumentMultimap**` is a class that stores all the parsed parameters taken from the user input.

Since the user input is valid, the `Transaction` is successfully created and inserted into the transaction list. The transaction list now contains 1 `Transaction` object.

image::add-command/AddTransactionToList1.png[]

Step 2. The user executes **add i/ n/Salary a/3000 d/2020-02-03 r/Monthly Salary c/income ** to indicate his monthly pay, to insert a positive `**Transaction**`.
The input is now checked in a similar fashion as in Step 1 except that:

* `**Remark**` is parsed by `AddCommandParser#parseRemark(ArgumentMultimap)`
* `**Category**` is parsed by `AddCommandParser#parseCategory(ArgumentMultimap)`

NOTE: `**Category**` has a set enum list of values FOOD, SHOPPING, TRANSPORT, GROCERIES, HEALTH, RECREATION, MISC, UTILITIES, INCOME.

Again, since the input is valid, the positive `Transaction` is successfully added into the transaction list. The transaction list
now contains 2 `**Transaction**` objects.

image::add-command/AddTransactionToList2.png[]

The following activity diagram summarizes what happens when the user executes a command to add a new `Transaction`:

image::add-command/AddTransactionActivityDiagram.png[]

Figure 10. Activity diagram of adding a `Transaction` into the transaction list.

Hubert Halim

// tag::setbudget[]
=== Setting budgets
We allow the user to maintain a `**Budget**` for the current month and subsequent months. This section details how `**ExpenseLa**` handles
requests made by the user who is trying to set a budget both for a one time and recurring budget. `**Budget**` is contained inside
`**MonthlyData**` object along with `**Expense**` and `**Income**` and application only has 1 `**MonthlyData**` object for the current month.
object looks like:

image::set-budget/BudgetClassDiagram.png[]

If user decides to create a recurring budget, there'll be additional step of updating the `**recurringBudget**` variable in
`**GlobalData**`. `**BudgetCommand**` in addition to modifying `**Budget**` in `**MonthlyData**`, it will also modify `**recurringBudget**`
in `**GlobalData**`.

image::set-budget/GlobalDataClassDiagram.png[]


==== Implementation
Whenever the user attempts to set a new `**Budget**`, `**ExpenseLa**` will create a new MonthlyData object with the given amount.
The application will then call `ModelManager#setMonthlyData(MonthlyData toSet)`. During the creation of the new MonthlyData, the
Budget class will internally check if the budget amount is valid.

We will demonstrate what happens at the back-end whenever the user sets a budget:

Case 1. The user wishes to set their budget to $1500, non-recurring. They execute the command: **budget b/1500**.
The user's entry is checked by `BudgetCommandParser#parse()` and an attempt to parse each parameter occurs:

* `**Budget**` is parsed by `ParseUtil#parseBudget(ArgumentMultimap)`
* `rc/` prefix does not exist, so it is not recurring

NOTE: `**ArgumentMultimap**` is a class that stores all the parsed parameters taken from the user input.

Since the user input is valid, the `**Budget**` is successfully created and inserted into a newly created `**MonthlyData**`.

Case 2. The user made a typo when setting their budget. They execute the command **budget b/150o**.
The user's entry is checked by `BudgetCommandParser#parse()` and an attempt to parse each parameter occurs:

* `**Budget**` is parsed by `ParseUtil#parseBudget(ArgumentMultimap)`

`**Budget**` class then is attempted to be created with the parsed budget amount in the constructor. Internally
Budget will do a validity check using Regex and throw a `**ParseExection**` since amount is not valid.

Case 3. The user wishes to set their budget to $1500, recurring. They execute the command: **budget b/1500 rc/**.
The user's entry is checked by `BudgetCommandParser#Parse()` and an attempt to parse each parameter occurs:

* `**Budget**` is parsed by `ParseUtil#parseBudget(ArgumentMultimap)`
* `rc/` prefix exists, so it is recurring

Since the user input is valid, the `**Budget**` is successfully created and inserted into a newly created `**MonthlyData**`.
BudgetCommand will then modify `**GlobalData**` in `**Model**` by calling `**Logic#setGlobalData**`. `**RecurringBudget**`
value in `**GlobalData**` is now set to the new `**Budget**`

The sequence diagram below depicts what was just elaborated:

.Sequence diagram showing how a `**Budget**` is set
image::set-budget/SetBudgetSequenceDiagram.png[]

.Activity diagram showing how a `**Budget**` is set
image::set-budget/SetBudgetActivityDiagram.png[]

==== Design considerations
We have considered various ways as to how `**Budget**` should be stored in `**ExpensLa**`. In this section, we will explain the
rationale on our course of actions.

===== Aspect: Make `**Budget**` a part of a bigger class called `**MonthlyData**`
* **Alternative 1 (current choice):** `**Budget**` is a part of `**MonthlyData**` and any `**Budget**` operations is through `**MonthlyData**`
** Pros: Easier to handle `**Budget**` together with other `**MonthlyData**` objects and all data inside is synchronised as it is
handled by a single object.
** Cons: Overhead when modifying `**Budget**` as to maintain immutability, a new `**MonthlyData**` object has to be created.
* Alternative 2: `**Budget**` should be an independent class with a direct reference in `**ExpenseLa**`.
** Pros: More freedom and efficiency in doing modifications on `**Budget**`
** Cons: Need to maintain more references for all different objects.

Again, we went with alternative 1 because it is easier to view `**Budget**` along with the other `**MonthlyData**` components
as a collective. And easier to just handle 1 reference in ExpenseLa.
// end::setbudget[]


// tag::commandHistoryNavigation[]
=== Command History navigation
Users can navigate to previous commands by pressing the up or down button on the keyboard.
Only successful commands are stored in the CommandHistory list and only a maximum of 50 commands can
be stored at a time.

==== Implementation
Every time the user key in a command and press kbd:[Enter], `CommandBox#handleCommandEntered` method will be called.
The method will attempt to execute the command by calling `CommandExecutor#execute` method. That method throws an error
if command is invalid. So if the command is valid, the `CommandBox#handleCommandEntered` method will call
`Logic#deleteCommandFromHistory` to delete the command if it exists in the current command history.
It will then call `Logic#addToCommandhistory` to add the command to the command history as its latest entry.

`Command History` is an array list that resides in `ModelManager` object. It can be accessed through `Logic` by calling
// end::commandHistoryNavigation[]


=== Filtering Transactions

The `Filter` command allows the user to bring up a list of `Transaction`, and filter it by either category, month,
or both at the same time. This is implemented by using a predicate for category and another predicate for month,
both of which inheriting from `Predicate<Transaction>` to filter the `Transaction`.

==== Implementation

`FilterCommand` is instantiated by `FilterCommandParser` 's `parse(String args)` method, which parses the arguments supplied in the user
command to return a `FilterCommand` object.

The below sequence diagram depicts the execution of the filter feature:
image:filter/FilterSequenceDiagram.png[]

The below scenario shows a typical usage of the filter feature:

Step 1: User executes the command filter c/FOOD m/2020-02 to bring up transactions in the category "FOOD" for the month
of February 2020.

Step 2: The `FilterCommandParser` will parse the arguments using the method `parse(String args)`.

Step 3: Since user input is correct and the arguments are parsed, a new `FilterCommand` object is created by the
`FilterCommandParser`.

Step 4: The `FilterCommand` object will use a `Predicate` based on the specified category, month, or both, to filter
the list of transactions.

Step 5: The list of filtered transactions is brought up. The filter category and month UI will also update accordingly
to show the category and month that the transactions are filtered by.

The below activity diagram gives an overview of the command execution:
image:filter/FilterActivityDiagram.png[]

==== Design Considerations

Aspect: Using `Predicate` to improve extendability of the `Filter` feature in the future.

* The filter feature supports increasing the number of filter types - on top of the current category and month filters.
* This is enabled by using a different `Predicate` for each filter type.
* A composed `Predicate` would then be obtained by calling `Predicate` 's `and(Predicate other)` method.
* This composed `Predicate` is then applied to filter the list of `Transaction`.

==== Proposed Extension

We plan to enhance the filter feature to support other arguments in the command to filter by different types such as
price range or date range. This allows the user to have greater flexibility and have a better understanding of his/her
expenses.

The design consideration mentioned earlier hence facilitates this proposed extension, reducing the difficulty of such a
future implementation.

=== Chart Analytics

The *toggleview* command allows the user to switch between viewing the list of 'Transactions' and viewing an analysis of
his expenditure.

==== Implementation

`MainWindow` decides whether to show a list of transactions or chart analysis based on `ToggleView#isViewList`, by accessing
`Logic#getToggleView()`.

Here is a Class Diagram for the implementatino of `ToggleView`:
image:chart-analytics/ToggleViewClassDiagram.png[]
Figure XX. Implementation of `ToggleView` class

The *ToggleView* mechanism utilizes `Logic` operations with the `ToggleViewCommand` class in place of `Command`. The following
methods are concrete implementations for the *toggle* operation:

* `ToggleViewCommand#execute()` - Modifies the `ToggleView` in `Model` to view list of transactions or view analytics, and
returns a `CommandResult` (<<Design-Logic, Step 4 of Logic>>).
* `ToggleView#switchIsViewList()` - Modifies the boolean value `isViewList` in `ToggleView` to the negation of it's
current value.
- This `ToggleView` is wrapped in `ExpenseLa` and its `switchIsViewList()` is called through
`ExpenseLa#switchToggleView()`.
- `ExpenseLa#switchToggleView()` is exposed in the `Model` interface as `Model#switchToggleView()`.

The following sequence diagram illustrates **toggleview** command execution:
image:chart-analytics/ToggleViewSequenceDiagram.png[]
Figure XX. Sequence diagram for **toggleview** execution

===== Example of usage
Given next is an example and explanation of how the **ToggleView** mechanism behaves at each step:

Step 1. The user starts up the application with an initial list loaded from external storage file. The diagram here
depicts the example list used throughout this scenario.

:figure-caption!:
.Example list on startup
image::clone/cloneDG/CloneStep3.png[,650]

Step 2. The user inputs **toggleview** to change the view from list of transactions to chart analysis.

.User input for toggle view
image::update/updateDG/UpdateStep2.png[,650]

Step 3. `ToggleViewCommand#execute()` switches `isViewList` of `ToggleView` from true to false.

.`isViewList` of `ToggleView` switched from `ToggleViewCommand#execute()`
image::update/updateDG/UpdateStep3.png[,650]

Step 4. `MainWindow#executeCommand()` checks the boolean value of isViewList which is false, and displays chart analysis.

image::update/updateDG/UpdateStep4Part1.png[,650]
.Switched from showing list of transactions to chart analysis
image::update/updateDG/UpdateStep4Part3.png[,650]

Step 5. User inputs **toggleview** again to change view back to list of transactions.

.Switched from showing list of transactions to chart analysis
image::update/updateDG/UpdateStep4Part3.png[,650]

===== Execution shown to user
The following activity diagram gives an overview of what ExpenseLa shows the user when executing **toggleview** command:

:figure-caption: Figure
.Activity diagram for execution of toggleview command
image::chart-analytics/ToggleViewActivityDiagram.png[]

=== Logging

We are using `java.util.logging` package for logging. The `LogsCenter` class is used to manage the logging levels and logging destinations.

* The logging level can be controlled using the `logLevel` setting in the configuration file (See <<Implementation-Configuration>>)
* The `Logger` for a class can be obtained using `LogsCenter.getLogger(Class)` which will log messages according to the specified logging level
* Currently log messages are output through: `Console` and to a `.log` file.

*Logging Levels*

* `SEVERE` : Critical problem detected which may possibly cause the termination of the application
* `WARNING` : Can continue, but with caution
* `INFO` : Information showing the noteworthy actions by the App
* `FINE` : Details that is not usually noteworthy but may be useful in debugging e.g. print the actual list instead of just its size

[[Implementation-Configuration]]
=== Configuration

Certain properties of the application can be controlled (e.g user prefs file location, logging level) through the configuration file (default: `config.json`).

== Documentation

Refer to the guide <<Documentation#, here>>.

== Testing

Refer to the guide <<Testing#, here>>.

== Dev Ops

Refer to the guide <<DevOps#, here>>.

[appendix]
== Product Scope

*Target user profile*:

* has a need to keep track of their expenses
* prefer desktop apps over other types
* can type fast
* prefers typing over mouse input
* is reasonably comfortable using CLI apps

*Value proposition*: efficient way to keep track of expenses and make decisions based on data and analytics provided

[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="59%",cols="22%,<23%,<25%,<30%",options="header",]
|=======================================================================
|Priority |As a ... |I want to ... |So that I can...
|`* * *` |new user |see usage instructions |refer to instructions when I forget how to use the App

|`* * *` |user |add a new expense entry |

|`* * *` |user |add a new income entry |

|`* * *` |user |set budget for current month |

|`* * *` |user |set budget for every month(recurrent budget) once |budget for subsequent months are automatically set

|`* * *` |user |be visually alerted when i spend a certain proportion of my budget |adjust my spending habit for the rest of the month

|`* * *` |user |delete an expense or income entry |remove entries that I added in by mistake

|`* * *` |user |find an entry by keyword |locate details of my expense or income

|`* * *` |user |filter expense based on category |see how much money i spend on that particular category

|`* * *` |user |filter expense based on date or time period |see how much money i spend in that time period

|`* * *` |user |view amount of budget left to spend |adjust spending habit for the rest of the month

|`* * *` |user |view total money i have |

|`* * *` |user |view total expense for a particular month |

|`* * *` |user |view pie chart of money spent based on category |see where i spend the most money on

|`* * *` |user |view bar chart of money spent based on time period |see when i spend the most money

|`* *` |user |add friends in the application

|`* *` |user |look at my friend's spending habit

|`*` |user who owes people money |view the people who i owe money to |

|`*` |user who lends people money |request payment from people who owe me money|

|=======================================================================

_{More to be added}_

[appendix]
== Use Cases

(For all use cases below, the *System* is the `ExpenseLa` and the *Actor* is the `user`, unless specified otherwise)

[discrete]
=== Use case: Delete expense

*MSS*

1.  User requests to list expenses
2.  System shows a list of expenses
3.  User requests to delete a specific expense in the list
4.  System deletes the expense
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

* 3a. The given index is invalid.
+
[none]
** 3a1. System shows an error message.
+
Use case resumes at step 2.

=== Use case: filter transactions by category

*MSS*

1.  User requests to list filtered expenses
2.  System queries list of expenses
3.  Add all expenses in given category to filtered list
4.  System shows filtered list
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

* 3a. The category given is not valid.
+
[none]
** 3a1. System shows an error message.
+
Use case resumes at step 2.

_{More to be added}_

[appendix]
== Non Functional Requirements

.  Should work on any <<mainstream-os,mainstream OS>> as long as it has Java `11` or above installed.
.  Should be able to hold up to 2000 transactions(expenses and incomes) without any apparent slowdown for normal usage.
.  A user with above average typing speed for regular English text (i.e. not code, not system admin commands) should be able to accomplish most of the tasks faster using commands than using the mouse.

_{More to be added}_

[appendix]
== Glossary

[[mainstream-os]] Mainstream OS::
Windows, Linux, Unix, OS-X

[appendix]
== Product Survey

*Product Name*

Author: ...

Pros:

* ...
* ...

Cons:

* ...
* ...

[appendix]
== Instructions for Manual Testing

Given below are instructions to test the app manually.

[NOTE]
These instructions only provide a starting point for testers to work on; testers are expected to do more _exploratory_ testing.

=== Launch and Shutdown

. Initial launch

.. Download the jar file and copy into an empty folder
.. Double-click the jar file +
   Expected: Shows the GUI with a set of sample contacts. The window size may not be optimum.

. Saving window preferences

.. Resize the window to an optimum size. Move the window to a different location. Close the window.
.. Re-launch the app by double-clicking the jar file. +
   Expected: The most recent window size and location is retained.

_{ more test cases ... }_

=== Deleting a person

. Deleting a person while all persons are listed

.. Prerequisites: List all persons using the `list` command. Multiple persons in the list.
.. Test case: `delete 1` +
   Expected: First contact is deleted from the list. Details of the deleted contact shown in the status message. Timestamp in the status bar is updated.
.. Test case: `delete 0` +
   Expected: No person is deleted. Error details shown in the status message. Status bar remains the same.
.. Other incorrect delete commands to try: `delete`, `delete x` (where x is larger than the list size) _{give more}_ +
   Expected: Similar to previous.

_{ more test cases ... }_

=== Saving data

. Dealing with missing/corrupted data files

.. _{explain how to simulate a missing/corrupted file and the expected behavior}_

_{ more test cases ... }_

